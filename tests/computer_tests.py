"""Unit Tests for the class Computer."""

import pytest
from program.computer import Computer


# TEST INIT
def test_init_values():
    """Test that __init__ sets __username, difficulty, id, dice_hand, score, and turn_number.

    test those: __username = __username
    self.difficulty = difficulty  # has to be a tuple
    self.id = hash(__username + difficulty)
    self.dice_hand = DiceHand()  # create dice_hand obj once class is integrated
    self.score = 0
    self.turn_number = 0
    """
    assert True


def test_init_class():
    """Test that creating a Computer instance returns a Computer object."""
    test_pc = Computer("Nephilim", 1)
    assert isinstance(test_pc, Computer)


def test_init_same_name_value():
    """Test that the provided __username is stored correctly in the instance."""
    name_exp = "Nephilim"
    test_pc = Computer(name_exp, 1)
    assert test_pc.__username == name_exp


def test_init_values_empty_value_computer_name():
    """Test that __username is not empty even when initialized with an empty string."""
    test_pc = Computer("", 1)
    assert test_pc.__username != ""


def test_init_values_None_value_computer_name():
    """Test that __username becomes a string when initialized with None."""
    test_pc = Computer(None, 1)
    assert isinstance(test_pc.__username, str)


def test_init_values_dict_value_computer_name():
    """Test that a dictionary input for __username is converted to a string."""
    test_pc = Computer({4: 5, 8: 2}, 1)
    assert isinstance(test_pc.__username, str)


def test_init_values_list_value_computer_name():
    """Test that a list input for __username is handled properly."""
    test_pc = Computer([4, 7, 9], 1)
    assert isinstance(test_pc.__username, str)


# init difficulty check (difficulty as index)


def test_init_difficulty_None():
    """Check of difficulty parameter as None."""
    with pytest.raises(TypeError, match="type is <class 'NoneType'>"):
        Computer("Harald", None)


def test_init_difficulty_non_valid_str():
    """Check of difficulty parameter as an invalid string."""
    with pytest.raises(ValueError, match="value is a non-valid string"):
        Computer("Harald", "idbfv")


def test_init_difficulty_list():
    """Check of difficulty parameter as a list."""
    with pytest.raises(TypeError, match="type is <class 'list'>"):
        Computer("Haradl", [1, "apple"])


def test_init_difficulty_tuple():
    """Check of difficulty parameter as a tuple."""
    with pytest.raises(TypeError, match="type is <class 'tuple'>"):
        Computer("Haradl", (1, "apple"))


def test_init_difficulty_dict():
    """Check of difficulty parameter as a dict."""
    with pytest.raises(TypeError, match="type is <class 'dict'>"):
        Computer("Haradl", {"sup": "nothing"})


def test_init_difficulty_computer():
    """Check of difficulty parameter as a Computer Obj."""
    with pytest.raises(TypeError, match="type is <class 'program.computer.Computer'>"):
        Computer("Haradl", Computer("Kopenhagen", 1))


def test_init_difficulty_invalid_index():
    """Check of difficulty parameter as an invalid index."""
    with pytest.raises(IndexError, match="Index Error Out of Bounds"):
        Computer("haradl", -2)


# positive tests
def test_init_difficulty_valid_str():
    """Check of difficulty parameter as a valid parameter."""
    test = Computer("hardal", "easy")
    assert test.difficulty == 0


def test_init_difficulty_valid_index():
    """Check of difficulty parameter as a valid index."""
    test = Computer("hardal", 2)
    assert test.difficulty == 2


def test_init_hash_same_input_produces_same_id():
    """Test that identical name and difficulty produce the same hash id within one session."""
    pc1 = Computer("Nephilim", 1)
    pc2 = Computer("Nephilim", 1)
    assert pc1.id == pc2.id


def test_hash_differs_for_different_inputs():
    """Test that different names or difficulties produce different hash ids."""
    pc1 = Computer("Nephilim", 1)
    pc2 = Computer("Clayman", 1)
    assert pc1.id != pc2.id


def test_hash_is_integer_type():
    """Test that id generated by hash() is an integer."""
    test_pc = Computer("Nephilim", 1)
    assert isinstance(test_pc.id, int)


# test that you can't change self.__username value?


# TEST ID?
def test_init_values_hash():
    """No clue whats happening here.

    self.id = hash(__username + difficulty)
    self.dice_hand = DiceHand()  # create dice_hand obj once class is integrated
    self.score = 0
    self.turn_number = 0
    """
    assert True


def test_difficulty_values():
    """No clue what is happening here."""
    assert True


# DIFFICULTY CHANGE
def test_select_difficulty_int():
    """Test for changing the difficulty via index/number."""
    test = Computer("harald", 1)
    assert test.select_difficulty(2) == "Difficulty changed to: hard"


def test_select_difficulty_str():
    """Test for changing the difficulty with a string."""
    test = Computer("harald", 0)
    assert test.select_difficulty("normal") == "Difficulty changed to: normal"


# TEST CHANGE COMPUTER NAME
def test_change_computer_name():
    """Test that change_computer_name() successfully updates __username."""
    test_pc = Computer("Name1", 1)
    exp = "Nephilim"
    test_pc.change_computer_name(exp)
    assert test_pc.__username == exp


def test_change_name_same_id():
    """Test that changing __username does not alter the computer's unique ID."""
    test_pc = Computer("Name1", 1)
    first_id = test_pc.id
    test_pc.change_computer_name("Cool new name")
    second_id = test_pc.id
    assert first_id == second_id


def test_change_name_empty_value():
    """Test that empty string input does not overwrite the existing __username."""
    first_name = "Name1"
    empty_name = ""
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(empty_name)
    assert test_pc.__username != empty_name


def test_change_name_dictionary_value():
    """Check that __username can handle dictionary value."""
    first_name = "Name1"
    dict_name = {1: 4, 6: 2}
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(dict_name)
    print(test_pc.__username)
    assert isinstance(test_pc.__username, str)


def test_change_name_list_value():
    """Check that __username can handle list value."""
    first_name = "Name1"
    list_name = [2, 4, 8, 0]
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(list_name)
    assert isinstance(test_pc.__username, str)


def test_change_name_None_value():
    """Check that __username can handle None."""
    first_name = "Name1"
    none_name = None
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(none_name)
    assert isinstance(test_pc.__username, str)


def test_roll_dice_type():
    """Test that roll_dice() returns an integer value."""
    test_pc = Computer("Nephilim", 1)
    test_dice = test_pc.roll_dice()
    assert isinstance(test_dice, int)


def test_hold_at_twenty(monkeypatch):
    """Force dice to always roll 5 -> stops after reaching >= 20."""
    test_pc = Computer("Nephilim", 1)
    monkeypatch.setattr("program.computer.Dice.roll_dice", lambda: 5)
    result = test_pc.hold_at_twenty()
    assert result == 20  # 5+5+5+5


def test_hold_at_twenty_roll_one(monkeypatch):
    """Test that hold_at_twenty() stops rolling when total reaches or exceeds 20."""
    rolls = iter([4, 1])  # roll 4, then 1
    monkeypatch.setattr("program.computer.Dice.roll_dice", lambda: next(rolls))
    test_pc = Computer("Nephilim", 1)
    result = test_pc.hold_at_twenty()
    assert result == 0  # resets after rolling 1


def test_take_turn_calls_correct():
    """No clue what is happening here."""
    assert True


def test_scoring_turn():
    """No clue what is happening here."""
    assert True


def test_keep_or_race():
    """No clue what is happening here."""
    assert True


def test_take_turn():
    """No clue what is happening here."""
    assert True


def test_():
    """."""
    assert True
