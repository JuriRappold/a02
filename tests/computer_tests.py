from program.computer import Computer
import pytest

# TEST INIT
def test_init_values():
    """Test that __init__ sets computer_name, difficulty, id, dice_hand, score, and turn_number."""
    '''test those: computer_name = computer_name
        self.difficulty = difficulty  # has to be a tuple
        self.id = hash(computer_name + difficulty)
        self.dice_hand = DiceHand()  # create dice_hand obj once class is integrated
        self.score = 0
        self.turn_number = 0  '''
    assert True

def test_init_class():
    """Test that creating a Computer instance returns a Computer object."""
    test_pc = Computer('Nephilim', 1)
    assert type(test_pc) == Computer 

def test_init_same_name_value():
    """Test that the provided computer_name is stored correctly in the instance."""
    name_exp = 'Nephilim'
    test_pc = Computer(name_exp, 1)
    assert  test_pc.computer_name == name_exp 

def test_init_values_empty_value_computer_name():
    """Test that computer_name is not empty even when initialized with an empty string."""
    test_pc = Computer('', 1)
    assert test_pc.computer_name != ''


def test_init_values_None_value_computer_name():
    """Test that computer_name becomes a string when initialized with None."""
    test_pc = Computer(None, 1)
    assert type(test_pc.computer_name) == str


def test_init_values_dict_value_computer_name():
    """Test that a dictionary input for computer_name is converted to a string."""
    test_pc = Computer({4:5,8:2}, 1)
    assert type(test_pc.computer_name) == str


def test_init_values_list_value_computer_name():
    """Test that a list input for computer_name is handled properly."""
    test_pc = Computer([4,7,9], 1)
    assert type(test_pc.computer_name) == str

# init difficulty check (difficulty as index)

def test_init_difficulty_None():
    with pytest.raises(TypeError, match="type is <class 'NoneType'>"):
        test = Computer("Harald", None)

def test_init_difficulty_non_valid_str():
    with pytest.raises(ValueError, match="value is a non-valid string"):
        test = Computer("Harald", "idbfv")

def test_init_difficulty_list():
    with pytest.raises(TypeError, match="type is <class 'list'>"):
        test = Computer("Haradl", [1, "apple"])

def test_init_difficulty_tuple():
    with pytest.raises(TypeError, match="type is <class 'tuple'>"):
        test = Computer("Haradl", (1, "apple"))

def test_init_difficulty_dict():
    with pytest.raises(TypeError, match="type is <class 'dict'>"):
        test = Computer("Haradl", {"sup": "nothing"})

def test_init_difficulty_computer():
    with pytest.raises(TypeError, match="type is <class 'program.computer.Computer'>"):
        test = Computer("Haradl", Computer("Kopenhagen", 1))
    #with pytest.raises(Tyo)
def test_init_difficulty_invalid_index():
    with pytest.raises(IndexError, match="Index Error Out of Bounds"):
        test = Computer("haradl", -2)
# positive tests
def test_init_difficulty_valid_str():
    test = Computer("hardal", "easy")
    assert test.difficulty == 0

def test_init_difficulty_valid_index():
    test = Computer("hardal", 2)
    assert test.difficulty == 2





def test_init_hash_same_input_produces_same_id():
    """Test that identical name and difficulty produce the same hash id within one session."""
    pc1 = Computer("Nephilim", 1)
    pc2 = Computer("Nephilim", 1)
    assert pc1.id == pc2.id

def test_hash_differs_for_different_inputs():
    """Test that different names or difficulties produce different hash ids."""
    pc1 = Computer("Nephilim", 1)
    pc2 = Computer("Clayman", 1)
    assert pc1.id != pc2.id


def test_hash_is_integer_type():
    """Test that id generated by hash() is an integer."""
    test_pc = Computer("Nephilim", 1)
    assert isinstance(test_pc.id, int)


# test that you can't change self.computer_name value?

# TEST ID?
def test_init_values_hash():
    '''
        self.id = hash(computer_name + difficulty)
        self.dice_hand = DiceHand()  # create dice_hand obj once class is integrated
        self.score = 0
        self.turn_number = 0  '''
    assert True

def test_difficulty_values():
    assert True


# DIFFICULTY CHANGE


# TEST CHANGE COMPUTER NAME
def test_change_computer_name():
    """Test that change_computer_name() successfully updates computer_name."""
    test_pc = Computer('Name1', 1)
    exp = 'Nephilim'
    test_pc.change_computer_name(exp)
    assert test_pc.computer_name == exp

def test_change_name_same_id():
    """Test that changing computer_name does not alter the computer's unique ID."""
    test_pc = Computer('Name1', 1)
    first_id = test_pc.id
    test_pc.change_computer_name('Cool new name')
    second_id = test_pc.id
    assert first_id == second_id

def test_change_name_empty_value():
    """Test that empty string input does not overwrite the existing computer_name."""
    first_name = 'Name1'
    empty_name = ''
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(empty_name)
    assert test_pc.computer_name != empty_name

def test_change_name_dictionary_value():
    """check that computer_name can handle dictionary value"""
    first_name = 'Name1'
    dict_name = {1:4,6:2}
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(dict_name)
    print(test_pc.computer_name)
    assert type(test_pc.computer_name) == str

def test_change_name_list_value():
    """check that computer_name can handle list value"""
    first_name = 'Name1'
    list_name = [2,4,8,0]
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(list_name)
    assert type(test_pc.computer_name) == str

def test_change_name_None_value():
    """check that computer_name can handle None"""
    first_name = 'Name1'
    none_name = None
    test_pc = Computer(first_name, 1)
    test_pc.change_computer_name(none_name)
    assert type(test_pc.computer_name) == str

def test_roll_dice_type():
    """Test that roll_dice() returns an integer value."""
    test_pc = Computer("Nephilim", 1)
    test_dice = test_pc.roll_dice()
    assert type(test_dice) == int

def test_hold_at_twenty(monkeypatch):
    """force dice to always roll 5 -> stops after reaching >= 20"""
    test_pc = Computer('Nephilim', 1)
    monkeypatch.setattr('program.computer.Dice.roll_dice', lambda: 5)
    result = test_pc.hold_at_twenty()
    assert result == 20  # 5+5+5+5

def test_hold_at_twenty_roll_one(monkeypatch):
    """Test that hold_at_twenty() stops rolling when total reaches or exceeds 20."""
    rolls = iter([4, 1])  # roll 4, then 1
    monkeypatch.setattr('program.computer.Dice.roll_dice', lambda: next(rolls))
    test_pc = Computer('Nephilim', 1)
    result = test_pc.hold_at_twenty()
    assert result == 0  # resets after rolling 1

def test_take_turn_calls_correct():
    assert True

def test_scoring_turn():
    assert True

def test_keep_or_race():
    assert True

def test_take_turn():
    assert True

def test_():
    """."""
    assert True
